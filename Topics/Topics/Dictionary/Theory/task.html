<div class="step-text">
<p>Imagine that you're a birdwatcher sitting in the park and counting birds that you see. You've observed a dozen pigeons, 5 sparrows, and even one red crossbill! Now, suppose that you want to store these observations for later use. You need to remember exactly how many birds of each kind you've seen. So, a simple list with numbers won't do because you won't be able to tell which number refers to which bird. You need a data type that can associate one thing with another: in our case, the name of the bird with the number of observations.</p>
<p>Luckily, Python has such a type — <strong>dictionary</strong> (<code class="language-python">dict</code>). You can picture a real dictionary — a large book with definitions for a lot of words. The definition contains two parts: the word itself (let's call it a <strong>key</strong>) and the definition for it (a <strong>value</strong>). In our birdwatcher example, the keys are names of the birds ("pigeon", "sparrow", and "red crossbill") and the values are how many birds of that kind we've seen (12, 5 and 1, respectively).</p>
<p>In programming, dictionaries work in a similar way: if we want to store an object, we need to select some key for it and put our object as a value for that key into our dictionary.</p>
<h5 id="dictionary-creation">Dictionary creation</h5>
<p>A dictionary consists of a collection of <a class="theory-lookup not-relevant" href="/learn/step/6481" rel="noopener noreferrer nofollow" target="_blank" title="In Python, a key-value pair is a data structure that maps unique keys to associated values in a dictionary. | Each key is used to look up its corresponding value within the dictionary. The key must be immutable and hashable, while the value can be any Python object and can vary in type. Key-value pairs are useful for creating flexible, unordered collections of data where each element has a unique identifier. They are often used in scenarios where fast lookups and efficient storage are important.">key-value pairs</a>. Each key-value pair maps the key to its associated value. If you already know the values needed, then the easiest way to create a dictionary is to use the <strong>curly braces</strong> with a comma-separated list of <code class="language-python">key: value</code> pairs. If you want to create an empty dictionary, you can do so with the help of curly braces as well. Note that values in a dictionary can be of <strong>different types</strong>.</p>
<pre><code class="language-python">birds = {"pigeon": 12, "sparrow": 5, "red crossbill": 1}
prices = {'espresso': 5.0, 'americano': 8.0, 'latte': 10, 'pastry': 'various prices'}
empty_dict = {}

print(type(birds))  # &lt;class 'dict'&gt;
print(type(prices))  # &lt;class 'dict'&gt;
print(type(empty_dict))  # &lt;class 'dict'&gt;</code></pre>
<p>Another way to create a dictionary is to use the <code class="language-python">dict</code> <a class="theory-lookup not-relevant" href="/learn/step/6481" rel="noopener noreferrer nofollow" target="_blank" title="In Python, a constructor is a special method in a class that customizes the initial state of an instance when it is created. | It is a concept from object-oriented programming and a class can have one and only one constructor. When defining a constructor within a class, it is automatically invoked when a new instance of the class is created. The constructor takes the class itself as the first argument, represented by the keyword `self`, and it returns a new instance of the class. For example, when creating a new instance of the `river` class, the constructor takes the parameters `name` and `length` and returns a new instance of the `river` class with those attributes set. This new instance can then be used to access all methods of the class. In the case of the `query` class, the constructor generates an SQL statement for each column of the table and renames each column to a variable following the PEP convention.">constructor</a>.</p>
<pre><code class="language-python">another_empty_dict = dict()  # using the dict constructor

print(type(another_empty_dict))  # &lt;class 'dict'&gt;</code></pre>
<p>When creating a non-empty dictionary, a dict constructor can take a dictionary as an argument, and / or future <a class="theory-lookup not-relevant" href="/learn/step/6481" rel="noopener noreferrer nofollow" target="_blank" title="In Python, a dictionary key is a unique identifier used to access the corresponding value in a dictionary. | It is similar to the role of a word in a real dictionary, which serves as a lookup key to its definition. In the context of the provided text, the keys are the names of the birds, such as pigeon, sparrow, and red crossbill, and the values are the number of observations, such as 12, 5, and 1. In Python, dictionaries are enclosed in curly braces, and keys and values are separated by a colon.">dictionary keys</a> as arguments with assigned values, as in the example:</p>
<pre><code class="language-python"># note that the future dictionary keys are listed without quotes
prices_with_constr = dict({'espresso': 5.0}, americano=8.0, latte=10, pastry='various prices')

print(prices_with_constr)  # {'espresso': 5.0, 'americano': 8.0, 'latte': 10, 'pastry': 'various prices'}</code></pre>
<p>When we give the dict constructor dictionary keys with assigned values, as <code class="language-python">dict(americano=8.0)</code>, the left part of the expression is treated as a variable. In contrast to the use of curly braces, in which you can use integers as keys, keys in the dict constructor can't be an integer, a string in quotes, a list, a multiword expression, etc. That is, the following lines will give you an error:</p>
<pre><code class="language-python">d1 = dict(888=8.0)
d2 = dict("americano"=8.0)
d3 = dict(["americano", "filter"]=8.0)
d4 = dict(the best americano=8.0)</code></pre>
<p> </p>
<p>Overall, the curly braces and the dict constructor are interchangeable, just mind the feature given above.</p>
<p> </p>
<p>Finally, you can create a nested dictionary. It's a collection of dictionaries inside one single dictionary.</p>
<pre><code class="language-python"># a nested dictionary example
my_pets = {'dog': {'name': 'Dolly', 'breed': 'collie'},
           'cat': {'name': 'Fluffy', 'breed': 'maine coon'}}

# another nested dictionary example
# note that keys of the outer dictionary are numbers
digits = {1: {'Word': 'one', 'Roman': 'I'}, 
          2: {'Word': 'two', 'Roman': 'II'}, 
          3: {'Word': 'three', 'Roman': 'III'}, 
          4: {'Word': 'four', 'Roman': 'IV'}, 
          5: {'Word': 'five', 'Roman': 'V'}}</code></pre>
<h5 id="accessing-the-items">Accessing the items</h5>
<p>The syntax for <strong>accessing</strong> an item is quite simple — dictionary name followed by a key in square brackets <code class="language-python">[]</code>. This approach works both for adding objects to a dictionary and for reading them from there:</p>
<pre><code class="language-python">my_pet = {}

# add 3 keys and their values into the dictionary
my_pet['name'] = 'Dolly'
my_pet['animal'] = 'dog'
my_pet['breed'] = 'collie'

print(my_pet)  # {'name': 'Dolly', 'animal': 'dog', 'breed': 'collie'}

# get information from the dictionary about an added item
print(my_pet['name'])  # Dolly</code></pre>
<p>When working with a nested dictionary, getting the right value may be a little harder. As in our example, there are different levels and you need to stop at the right depth.</p>
<pre><code class="language-python"># our nested dictionary once again:
my_pets = {'dog': {'name': 'Dolly', 'breed': 'collie'},
           'cat': {'name': 'Fluffy', 'breed': 'maine coon'}}

print(my_pets['cat'])  # {'name': 'Fluffy', 'breed': 'maine coon'}

print(my_pets['cat']['breed'])  # maine coon</code></pre>
<h5 id="choosing-the-keys">Choosing the keys</h5>
<p>You can save objects of any type in a dictionary, but not all of them qualify as a key. You need a good, <strong>unique</strong> key for each object in your collection. Still, this is not the only restriction on dictionary keys and we will cover them later. For now, safely use numbers and strings.</p>
<p>If a key has already been added to your dictionary, its old value will be overwritten:</p>
<pre><code class="language-python">trilogy = {'IV': 'Star Wars', 'V': 'The Empire Strikes Back', 'VI': 'Return of the Jedi'}
print(trilogy['IV'])  # Star Wars

trilogy['IV'] = 'A New Hope'
print(trilogy['IV'])  # A New Hope</code></pre>
<p>In <strong>Python 3.7 and up</strong>, dictionaries do maintain the <strong><a class="theory-lookup not-relevant" href="/learn/step/6481" rel="noopener noreferrer nofollow" target="_blank" title="In Python, insertion order refers to the position in which an element is placed in a list when it is added. | Prior to Python 3.7, the order in which elements were inserted into a list was not guaranteed to be preserved. However, as of Python 3.7, the order of elements in a list is maintained as the order in which they were inserted. This is important because some algorithms, such as the insertion sort algorithm, rely on the order of elements in a list. When adding an element to a list, the `insert()` method is used, which takes an index as its first argument, indicating the position before which the new element will be inserted.">insertion order</a></strong> for values they store, but in previous versions it is not necessarily so:</p>
<pre><code class="language-python">alphabet = {}
alphabet['alpha'] = 1
alphabet['beta'] = 2

print(alphabet)
# Python 3.8 output: {'alpha': 1, 'beta': 2}</code></pre>
<h5 id="conclusion">Conclusion</h5>
<p>In this topic we've covered some basics for the <strong>dictionary </strong>data type in Python:</p>
<ul>
<li>how to create a dictionary,</li>
<li>what is a nested dictionary,</li>
<li>how to manage dictionary items: keys and values.</li>
</ul>
<p>In the following lesson you'll get acquainted with basic <a class="theory-lookup not-relevant" href="/learn/step/6481" rel="noopener noreferrer nofollow" target="_blank" title="In Python, an operation is a process or function that is performed on one or more values or variables. | This can include arithmetic operations such as addition or subtraction, as well as other types of operations like comparison or set operations. For example, you can perform a union operation on two sets to create a new set that contains all the elements of both initial sets. This can be done using the `union()` method or the `` operator. In the context of objects, defining methods for certain operations allows you to specify how those operations should be performed for that specific object.">operations</a> on dictionaries, but first, let's practice some tasks, so you would feel confident using this data type!</p>
</div>